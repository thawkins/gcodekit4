//! Designer Tool UI Panel  
//! Provides 2D CAD drawing interface with vertical toolbox and canvas interaction

import { Button, VerticalBox, HorizontalBox, ScrollView } from "std-widgets.slint";

component CompactSpinBox inherits Rectangle {
    in-out property <float> value;
    in property <float> minimum: 0;
    in property <float> maximum: 100;
    in property <float> step: 1.0;
    
    callback value-changed(float);
    
    background: white;
    border-width: 1px;
    border-color: #ccc;
    border-radius: 2px;
    
    HorizontalLayout {
        padding: 0px;
        spacing: 0px;
        
        Rectangle {
            horizontal-stretch: 1;
            
            text-input := TextInput {
                text: value;
                horizontal-alignment: center;
                vertical-alignment: center;
                font-size: 13px;
                
                edited => {
                    if (self.text != "") {
                        value = max(minimum, min(maximum, self.text.to-float()));
                        value-changed(value);
                    }
                }
            }
        }
        
        VerticalLayout {
            padding: 0px;
            spacing: 0px;
            width: 15px;
            
            Rectangle {
                height: 11px;
                background: up-touch.has-hover ? #e0e0e0 : #f5f5f5;
                border-width: 1px;
                border-color: #ccc;
                
                Text {
                    text: "▲";
                    font-size: 8px;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                }
                
                up-touch := TouchArea {
                    clicked => {
                        if (value < maximum) {
                            value = min(maximum, value + step);
                            value-changed(value);
                        }
                    }
                }
            }
            
            Rectangle {
                height: 11px;
                background: down-touch.has-hover ? #e0e0e0 : #f5f5f5;
                border-width: 1px;
                border-color: #ccc;
                
                Text {
                    text: "▼";
                    font-size: 8px;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                }
                
                down-touch := TouchArea {
                    clicked => {
                        if (value > minimum) {
                            value = max(minimum, value - step);
                            value-changed(value);
                        }
                    }
                }
            }
        }
    }
}

export struct DesignerShape {
    id: int,
    x: float,
    y: float,
    width: float,
    height: float,
    radius: float,
    x2: float,
    y2: float,
    shape_type: int,
    selected: bool,
}

export struct DesignerState {
    mode: int,
    zoom: float,
    pan_x: float,
    pan_y: float,
    selected_id: int,
}

component ToolButton inherits Rectangle {
    in property <int> tool_id;
    in property <int> current_mode;
    in property <string> icon_text;
    in property <string> tooltip;
    
    callback clicked;
    
    width: 48px;
    height: 48px;
    background: current_mode == tool_id ? #3498db : #2c3e50;
    border-width: 2px;
    border-color: current_mode == tool_id ? white : transparent;
    
    VerticalBox {
        alignment: center;
        Text {
            text: icon_text;
            font-size: 24px;
            horizontal-alignment: center;
            color: current_mode == tool_id ? white : #95a5a6;
        }
    }
    
    TouchArea {
        mouse-cursor: pointer;
        clicked => {
            root.clicked();
        }
    }
}

export component DesignerPanel inherits VerticalBox {
    spacing: 0px;
    horizontal-stretch: 1.0;
    vertical-stretch: 1.0;
    
    in property <[DesignerShape]> shapes: [];
    in property <DesignerState> designer_state;
    in-out property <float> feed_rate;
    in-out property <float> spindle_speed;
    in-out property <float> tool_diameter;
    in-out property <float> cut_depth;
    in property <string> generated_gcode: "";
    in property <bool> gcode_generated: false;
    in property <float> zoom_scale: 1.0;
    in property <float> x_offset: 0.0;
    in property <float> y_offset: 0.0;
    in property <image> canvas_image;
    in property <float> selected_shape_x: 0.0;
    in property <float> selected_shape_y: 0.0;
    in property <float> selected_shape_w: 0.0;
    in property <float> selected_shape_h: 0.0;
    
    callback set_mode(int);
    callback zoom_in();
    callback zoom_out();
    callback zoom_fit();
    callback reset_view();
    callback delete_selected();
    callback clear_canvas();
    callback generate_toolpath();
    callback export_gcode();
    callback update_feed_rate(float);
    callback update_spindle_speed(float);
    callback update_tool_diameter(float);
    callback update_cut_depth(float);
    callback import_dxf();
    callback import_svg();
    callback export_design();
    callback canvas_click(float, float);
    callback detect_handle(float, float) -> int;  // x, y - returns handle index (-1 if not on handle)
    callback shape_drag(int, float, float);        // shape_id, dx, dy
    callback handle_drag(int, int, float, float);  // shape_id, handle_index, dx, dy
    callback canvas_pan(float, float);             // dx, dy - pan the viewport
    callback deselect_all();
    callback set_shift_pressed(bool);              // Notify backend of Shift key state
    
    // Track last delta sent to backend (per shape) to compute incremental changes
    private property <float> drag_start_x: 0.0;
    private property <float> drag_start_y: 0.0;
    private property <float> drag_last_dx: 0.0;
    private property <float> drag_last_dy: 0.0;
    private property <int> dragging_shape_id: -1;
    private property <int> dragging_handle: -1;
    private property <bool> drag_occurred: false;
    private property <int> hovered_handle: -1;  // Track which handle we're hovering over
    private property <bool> drag_start_initialized: false;  // Track if drag_start has been set for current press
    private property <bool> shift_pressed: false;  // Track if Shift key is held
    
    // Main layout: vertical toolbox on left, canvas and properties on right
    FocusScope {
        width: 100%;
        height: 100%;
        
        key-pressed(event) => {
            if event.text == Key.Escape {
                deselect_all();
                accept
            } else if event.text == Key.Delete {
                delete_selected();
                accept
            } else if event.text == Key.Shift {
                root.shift_pressed = true;
                set_shift_pressed(true);
                accept
            } else {
                reject
            }
        }
        
        key-released(event) => {
            if event.text == Key.Shift {
                root.shift_pressed = false;
                set_shift_pressed(false);
                accept
            } else {
                reject
            }
        }
        
        HorizontalBox {
            spacing: 2px;
        
        // ═════════════════════════════════════════════
        // LEFT SIDEBAR: Tool Icons in 2-Column Grid
        // ═════════════════════════════════════════════
        VerticalBox {
            preferred-width: 110px;
            horizontal-stretch: 0;
            spacing: 0px;
            alignment: start;
            
            // Drawing Tools Section (6 buttons in 2x3 grid)
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                ToolButton {
                    tool_id: 0;
                    current_mode: designer_state.mode;
                    icon_text: "➜";
                    tooltip: "Select (S)";
                    clicked => { set_mode(0); }
                }
                ToolButton {
                    tool_id: 1;
                    current_mode: designer_state.mode;
                    icon_text: "▭";
                    tooltip: "Rectangle (R)";
                    clicked => { set_mode(1); }
                }
            }
            
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                ToolButton {
                    tool_id: 2;
                    current_mode: designer_state.mode;
                    icon_text: "●";
                    tooltip: "Circle (C)";
                    clicked => { set_mode(2); }
                }
                ToolButton {
                    tool_id: 3;
                    current_mode: designer_state.mode;
                    icon_text: "/";
                    tooltip: "Line (L)";
                    clicked => { set_mode(3); }
                }
            }
            
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                ToolButton {
                    tool_id: 4;
                    current_mode: designer_state.mode;
                    icon_text: "◯";
                    tooltip: "Ellipse (E)";
                    clicked => { set_mode(4); }
                }
                ToolButton {
                    tool_id: 5;
                    current_mode: designer_state.mode;
                    icon_text: "⬠";
                    tooltip: "Polygon (P)";
                    clicked => { set_mode(5); }
                }
            }
            
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                ToolButton {
                    tool_id: 6;
                    current_mode: designer_state.mode;
                    icon_text: "⬛";
                    tooltip: "Round Rectangle (U)";
                    clicked => { set_mode(6); }
                }
                Rectangle { }
            }
            
            // Separator
            Rectangle {
                height: 1px;
                background: #cccccc;
            }
            
            // View Controls (4 buttons in 2x2 grid)
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                Button {
                    text: "+";
                    width: 50px;
                    height: 40px;
                    clicked => { zoom_in(); }
                }
                Button {
                    text: "-";
                    width: 50px;
                    height: 40px;
                    clicked => { zoom_out(); }
                }
            }
            
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                Button {
                    text: "⊡";
                    width: 50px;
                    height: 40px;
                    clicked => { zoom_fit(); }
                }
                Button {
                    text: "⌂";
                    width: 50px;
                    height: 40px;
                    clicked => { reset_view(); }
                }
            }
            
            // Separator
            Rectangle {
                height: 1px;
                background: #cccccc;
            }
            
            // Edit Controls (2 buttons in 2x1 grid)
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                Button {
                    text: "✗";
                    width: 50px;
                    height: 40px;
                    clicked => { delete_selected(); }
                }
                Button {
                    text: "⊕";
                    width: 50px;
                    height: 40px;
                    clicked => { clear_canvas(); }
                }
            }
            
            // Separator
            Rectangle {
                height: 1px;
                background: #cccccc;
            }
            
            // Import/Export Controls (3 buttons in 2x2 grid, last empty)
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                Button {
                    text: "⇧";
                    width: 50px;
                    height: 40px;
                    clicked => { import_dxf(); }
                }
                Button {
                    text: "⇨";
                    width: 50px;
                    height: 40px;
                    clicked => { import_svg(); }
                }
            }
            
            HorizontalBox {
                spacing: 2px;
                padding: 2px;
                
                Button {
                    text: "⇩";
                    width: 50px;
                    height: 40px;
                    clicked => { export_design(); }
                }
                Rectangle { }
            }
            
            // Spacer to push content to top
            VerticalBox { }
        }
        
        // ═════════════════════════════════════════════
        // CENTER: Canvas Area
        // ═════════════════════════════════════════════
        VerticalBox {
            horizontal-stretch: 1;
            
            // Canvas Info Indicator
            Rectangle {
                height: 25px;
                background: white;
                border-width: 1px;
                border-color: #cccccc;
                
                HorizontalBox {
                    padding-left: 8px;
                    padding-right: 8px;
                    padding-top: 4px;
                    padding-bottom: 4px;
                    spacing: 0px;
                    alignment: start;
                    
                    // Zoom Scale
                    Text {
                        text: "Scale: " + Math.round(zoom_scale * 1000.0) / 10.0 + "%";
                        font-size: 13px;
                        font-weight: 700;
                        color: black;
                    }
                    
                    // Spacer
                    Rectangle { width: 20px; }
                    
                    // X Offset
                    Text {
                        text: "X: " + Math.round(x_offset * 10.0) / 10.0;
                        font-size: 13px;
                        color: black;
                    }
                    
                    // Spacer
                    Rectangle { width: 20px; }
                    
                    // Y Offset
                    Text {
                        text: "Y: " + Math.round(y_offset * 10.0) / 10.0;
                        font-size: 13px;
                        color: black;
                    }
                    
                    // Spacer before shape indicator
                    if designer_state.selected_id > 0 : Rectangle {
                        width: 20px;
                    }
                    
                    // Shape Indicator (X, Y, W, H) - shown only when shape is selected
                    if designer_state.selected_id > 0 : Text {
                        text: "| Shape: X=" + Math.round(root.selected_shape_x * 10.0) / 10.0 + 
                              " Y=" + Math.round(root.selected_shape_y * 10.0) / 10.0 +
                              " W=" + Math.round(root.selected_shape_w * 10.0) / 10.0 +
                              " H=" + Math.round(root.selected_shape_h * 10.0) / 10.0;
                        font-size: 13px;
                        color: #2980b9;
                        font-weight: 700;
                    }
                }
            }
            
            // Canvas with interactive area
            Rectangle {
                background: #2c3e50;
                vertical-stretch: 1;
                
                VerticalBox {
                    Rectangle {
                        vertical-stretch: 1;
                        background: #34495e;
                        
                        // Wrap canvas in FocusScope to enable mouse wheel handling
                        canvas_focus := FocusScope {
                            key-pressed(event) => {
                                if event.text == "+" || event.text == "=" {
                                    zoom_in();
                                    return accept;
                                } else if event.text == "-" {
                                    zoom_out();
                                    return accept;
                                } else if event.text == Key.Shift {
                                    root.shift_pressed = true;
                                    set_shift_pressed(true);
                                    return accept;
                                }
                                reject
                            }
                            
                            key-released(event) => {
                                if event.text == Key.Shift {
                                    root.shift_pressed = false;
                                    set_shift_pressed(false);
                                    return accept;
                                }
                                reject
                            }
                            
                            // Display rendered canvas image at native resolution (no scaling)
                            // ScrollView with TouchArea overlay for interaction
                            canvas_scroll := ScrollView {
                                viewport-width: 1600px;
                                viewport-height: 1200px;
                            
                            Rectangle {
                                width: 1600px;
                                height: 1200px;
                                
                                if root.canvas_image.width > 0 : Image {
                                    source: root.canvas_image;
                                    width: 1600px;
                                    height: 1200px;
                                }
                                
                                // Interactive layer on top of image
                                TouchArea {
                                    width: 100%;
                                    height: 100%;
                                    mouse-cursor: 
                                        designer_state.mode == 0 ? (
                                            root.hovered_handle == 0 || root.hovered_handle == 2 ? ns-resize :
                                            root.hovered_handle == 1 || root.hovered_handle == 3 ? ew-resize :
                                            root.dragging_shape_id >= 0 || (root.hovered_handle == 4 && designer_state.selected_id > 0) ? move :
                                            default
                                        ) :
                                        designer_state.mode == 1 ? crosshair :
                                        designer_state.mode == 2 ? crosshair :
                                        designer_state.mode == 3 ? crosshair :
                                        designer_state.mode == 4 ? crosshair :
                                        designer_state.mode == 5 ? crosshair :
                                        designer_state.mode == 6 ? crosshair :
                                        default;
                                    
                                    clicked => {
                                        // Don't handle click if a drag just occurred
                                        if !root.drag_occurred {
                                            // Adjust for scroll offset
                                            let adjusted_x = self.mouse-x / 1px + canvas_scroll.viewport-x / 1px;
                                            let adjusted_y = self.mouse-y / 1px + canvas_scroll.viewport-y / 1px;
                                            canvas_click(adjusted_x, adjusted_y);
                                        }
                                        root.drag_occurred = false;
                                    }
                                    
                                    // Detect handle on press down
                                    pointer-event(event) => {
                                        if event.kind == PointerEventKind.down {
                                            // Ensure FocusScope has focus so key events are captured
                                            canvas_focus.focus();
                                            if designer_state.mode == 0 {
                                                // Ask backend to detect which handle (if any) we're on
                                                let adjusted_x = self.pressed-x / 1px + canvas_scroll.viewport-x / 1px;
                                                let adjusted_y = self.pressed-y / 1px + canvas_scroll.viewport-y / 1px;
                                                root.dragging_handle = detect_handle(adjusted_x, adjusted_y);
                                                // Reset drag tracking for new press
                                                root.drag_start_initialized = false;
                                            }
                                        }
                                    }
                                    
                                    // Track mouse movement - detect dragging and hover
                                    moved => {
                                        if designer_state.mode == 0 {
                                            // Check which handle we're hovering over
                                            let adjusted_x = self.mouse-x / 1px + canvas_scroll.viewport-x / 1px;
                                            let adjusted_y = self.mouse-y / 1px + canvas_scroll.viewport-y / 1px;
                                            root.hovered_handle = detect_handle(adjusted_x, adjusted_y);
                                        }
                                        
                                        if designer_state.mode == 0 && self.pressed {
                                            // Initialize drag start on first move while pressed
                                            if !root.drag_start_initialized {
                                                root.drag_start_x = self.pressed-x / 1px;
                                                root.drag_start_y = self.pressed-y / 1px;
                                                root.drag_start_initialized = true;
                                                root.drag_last_dx = 0.0;
                                                root.drag_last_dy = 0.0;
                                            }
                                            
                                            let total_dx = (self.mouse-x / 1px - root.drag_start_x);
                                            let total_dy = (self.mouse-y / 1px - root.drag_start_y);
                                            let inc_dx = total_dx - root.drag_last_dx;
                                            let inc_dy = total_dy - root.drag_last_dy;
                                            
                                            if abs(inc_dx) > 0.5 || abs(inc_dy) > 0.5 {
                                                if root.dragging_handle >= 0 && root.dragging_handle <= 3 {
                                                    // Dragging a resize handle (0-3)
                                                    // Use current selected_id, not cached dragging_shape_id
                                                    handle_drag(designer_state.selected_id, root.dragging_handle, inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                } else if root.dragging_handle == 4 || (root.dragging_handle == -1 && designer_state.selected_id > 0) {
                                                    // Dragging the shape itself (move) - handle is -1 or 4 (center)
                                                    handle_drag(designer_state.selected_id, root.dragging_handle, inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                } else if root.dragging_handle == -1 && designer_state.selected_id == 0 {
                                                    // No shape selected - pan the canvas
                                                    canvas_pan(inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                }
                                                root.drag_last_dx = total_dx;
                                                root.drag_last_dy = total_dy;
                                            }
                                        } else if !self.pressed {
                                            // Reset when not pressed
                                            root.drag_last_dx = 0.0;
                                            root.drag_last_dy = 0.0;
                                            root.drag_start_initialized = false;
                                            root.dragging_handle = -1;
                                            root.dragging_shape_id = -1;
                                        }
                                    }
                                }
                            }
                        }
                        }
                    }
                    
                    Text {
                        text: "Canvas - " + shapes.length + " shapes | Mode: " + 
                              (designer_state.mode == 0 ? "Select" :
                               designer_state.mode == 1 ? "Rectangle" :
                               designer_state.mode == 2 ? "Circle" :
                               designer_state.mode == 3 ? "Line" :
                               designer_state.mode == 4 ? "Ellipse" :
                               designer_state.mode == 5 ? "Polygon" : "Round Rectangle");
                        font-size: 11px;
                    }
                }
            }
        }
        
        // ═════════════════════════════════════════════
        // RIGHT SIDEBAR: Properties Panel (Scrollable)
        // ═════════════════════════════════════════════
        ScrollView {
            preferred-width: 160px;
            max-width: 160px;
            horizontal-stretch: 0;
            
            Rectangle {
                background: #ecf0f1;
                width: 160px;
                
                VerticalBox {
                    spacing: 6px;
                    padding: 6px;
                    width: 100%;
                    
                    Text {
                        text: "Tool Setup";
                        font-weight: 700;
                        font-size: 11px;
                    }
                    
                    HorizontalBox {
                        spacing: 2px;
                        width: 100%;
                        Text { 
                            text: "Feed:"; 
                            font-size: 11px;
                            width: 50px;
                            vertical-alignment: center;
                        }
                        CompactSpinBox { 
                            value: root.feed_rate; 
                            minimum: 0;
                            maximum: 10000;
                            step: 10;
                            horizontal-stretch: 1;
                            height: 22px;
                            value-changed(v) => {
                                root.feed_rate = v;
                                root.update_feed_rate(v);
                            }
                        }
                    }
                    
                    HorizontalBox {
                        spacing: 2px;
                        width: 100%;
                        Text { 
                            text: "Speed:"; 
                            font-size: 11px;
                            width: 50px;
                            vertical-alignment: center;
                        }
                        CompactSpinBox { 
                            value: root.spindle_speed;
                            minimum: 0;
                            maximum: 30000;
                            step: 100;
                            horizontal-stretch: 1;
                            height: 22px;
                            value-changed(v) => {
                                root.spindle_speed = v;
                                root.update_spindle_speed(v);
                            }
                        }
                    }
                    
                    HorizontalBox {
                        spacing: 2px;
                        width: 100%;
                        Text { 
                            text: "Tool:"; 
                            font-size: 11px;
                            width: 50px;
                            vertical-alignment: center;
                        }
                        CompactSpinBox { 
                            value: root.tool_diameter;
                            minimum: 0;
                            maximum: 50;
                            step: 0.1;
                            horizontal-stretch: 1;
                            height: 22px;
                            value-changed(v) => {
                                root.tool_diameter = v;
                                root.update_tool_diameter(v);
                            }
                        }
                    }
                    
                    HorizontalBox {
                        spacing: 2px;
                        width: 100%;
                        Text { 
                            text: "Depth:"; 
                            font-size: 11px;
                            width: 50px;
                            vertical-alignment: center;
                        }
                        CompactSpinBox { 
                            value: root.cut_depth;
                            minimum: -100;
                            maximum: 0;
                            step: 0.1;
                            horizontal-stretch: 1;
                            height: 22px;
                            value-changed(v) => {
                                root.cut_depth = v;
                                root.update_cut_depth(v);
                            }
                        }
                    }
                    
                    Rectangle { height: 2px; }
                    
                    Text {
                        text: "G-Code";
                        font-weight: 700;
                        font-size: 11px;
                    }
                    
                    Button {
                        text: "Generate";
                        width: 100%;
                        clicked => { generate_toolpath(); }
                    }
                    
                    Button {
                        text: "Export";
                        width: 100%;
                        clicked => { export_gcode(); }
                    }
                    
                    Text {
                        text: gcode_generated ? "✓ Ready" : "⊘ None";
                        font-size: 8px;
                        color: gcode_generated ? #2ecc71 : #e74c3c;
                        horizontal-alignment: center;
                    }
                    
                    VerticalBox { }
                }
            }
        }
    }
    }
}
