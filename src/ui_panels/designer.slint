//! Designer Tool UI Panel  
//! Provides 2D CAD drawing interface with vertical toolbox and canvas interaction

import { Button, SpinBox, VerticalBox, HorizontalBox, ScrollView } from "std-widgets.slint";

export struct DesignerShape {
    id: int,
    x: float,
    y: float,
    width: float,
    height: float,
    radius: float,
    x2: float,
    y2: float,
    shape_type: int,
    selected: bool,
}

export struct DesignerState {
    mode: int,
    zoom: float,
    pan_x: float,
    pan_y: float,
    selected_id: int,
}

component ToolButton inherits Rectangle {
    in property <int> tool_id;
    in property <int> current_mode;
    in property <string> icon_text;
    in property <string> tooltip;
    
    callback clicked;
    
    width: 48px;
    height: 48px;
    background: current_mode == tool_id ? #3498db : #2c3e50;
    border-width: 2px;
    border-color: current_mode == tool_id ? white : transparent;
    
    VerticalBox {
        alignment: center;
        Text {
            text: icon_text;
            font-size: 24px;
            horizontal-alignment: center;
            color: current_mode == tool_id ? white : #95a5a6;
        }
    }
    
    TouchArea {
        mouse-cursor: pointer;
        clicked => {
            root.clicked();
        }
    }
}

export component DesignerPanel inherits VerticalBox {
    spacing: 0px;
    horizontal-stretch: 1.0;
    vertical-stretch: 1.0;
    
    in property <[DesignerShape]> shapes: [];
    in property <DesignerState> designer_state;
    in property <float> feed_rate: 120.0;
    in property <float> spindle_speed: 3000.0;
    in property <float> tool_diameter: 3.175;
    in property <float> cut_depth: -5.0;
    in property <string> generated_gcode: "";
    in property <bool> gcode_generated: false;
    in property <float> zoom_scale: 1.0;
    in property <float> x_offset: 0.0;
    in property <float> y_offset: 0.0;
    in property <image> canvas_image;
    
    callback set_mode(int);
    callback zoom_in();
    callback zoom_out();
    callback zoom_fit();
    callback reset_view();
    callback delete_selected();
    callback clear_canvas();
    callback generate_toolpath();
    callback export_gcode();
    callback canvas_click(float, float);
    callback detect_handle(float, float) -> int;  // x, y - returns handle index (-1 if not on handle)
    callback shape_drag(int, float, float);        // shape_id, dx, dy
    callback handle_drag(int, int, float, float);  // shape_id, handle_index, dx, dy
    callback canvas_pan(float, float);             // dx, dy - pan the viewport
    callback deselect_all();
    
    // Track last delta sent to backend (per shape) to compute incremental changes
    private property <float> drag_start_x: 0.0;
    private property <float> drag_start_y: 0.0;
    private property <float> drag_last_dx: 0.0;
    private property <float> drag_last_dy: 0.0;
    private property <int> dragging_shape_id: -1;
    private property <int> dragging_handle: -1;
    private property <bool> drag_occurred: false;
    private property <int> hovered_handle: -1;  // Track which handle we're hovering over
    private property <bool> drag_start_initialized: false;  // Track if drag_start has been set for current press
    
    // Main layout: vertical toolbox on left, canvas and properties on right
    FocusScope {
        width: 100%;
        height: 100%;
        
        key-pressed(event) => {
            if event.text == Key.Escape {
                deselect_all();
                accept
            } else if event.text == Key.Delete {
                delete_selected();
                accept
            } else {
                reject
            }
        }
        
        HorizontalBox {
            spacing: 2px;
        
        // ═════════════════════════════════════════════
        // LEFT SIDEBAR: Vertical Tool Icons
        // ═════════════════════════════════════════════
        VerticalBox {
            preferred-width: 54px;
            horizontal-stretch: 0;
            spacing: 2px;
            alignment: start;
            
            // Drawing Tools
            ToolButton {
                tool_id: 0;
                current_mode: designer_state.mode;
                icon_text: "➜";
                tooltip: "Select (S)";
                clicked => { set_mode(0); }
            }
            
            ToolButton {
                tool_id: 1;
                current_mode: designer_state.mode;
                icon_text: "▭";
                tooltip: "Rectangle (R)";
                clicked => { set_mode(1); }
            }
            
            ToolButton {
                tool_id: 2;
                current_mode: designer_state.mode;
                icon_text: "●";
                tooltip: "Circle (C)";
                clicked => { set_mode(2); }
            }
            
            ToolButton {
                tool_id: 3;
                current_mode: designer_state.mode;
                icon_text: "/";
                tooltip: "Line (L)";
                clicked => { set_mode(3); }
            }
            
            VerticalBox { } // Spacer
            
            // View Controls
            Button {
                text: "+";
                width: 50px;
                clicked => { zoom_in(); }
            }
            
            Button {
                text: "-";
                width: 50px;
                clicked => { zoom_out(); }
            }
            
            Button {
                text: "⊡";
                width: 50px;
                clicked => { zoom_fit(); }
            }
            
            Button {
                text: "⌂";
                width: 50px;
                clicked => { reset_view(); }
            }
            
            VerticalBox { } // Spacer
            
            // Edit Controls
            Button {
                text: "✗";
                width: 50px;
                clicked => { delete_selected(); }
            }
            
            Button {
                text: "⊕";
                width: 50px;
                clicked => { clear_canvas(); }
            }
        }
        
        // ═════════════════════════════════════════════
        // CENTER: Canvas Area
        // ═════════════════════════════════════════════
        VerticalBox {
            width: 75%;
            
            // Canvas Info Indicator
            Rectangle {
                height: 25px;
                background: white;
                border-width: 1px;
                border-color: #cccccc;
                
                HorizontalBox {
                    padding-left: 8px;
                    padding-right: 8px;
                    padding-top: 4px;
                    padding-bottom: 4px;
                    spacing: 20px;
                    
                    // Zoom Scale
                    Text {
                        text: "Scale: " + Math.round(zoom_scale * 1000.0) / 10.0 + "%";
                        font-size: 13px;
                        font-weight: 700;
                        color: black;
                    }
                    
                    // X Offset
                    Text {
                        text: "X: " + Math.round(x_offset * 10.0) / 10.0;
                        font-size: 13px;
                        color: black;
                    }
                    
                    // Y Offset
                    Text {
                        text: "Y: " + Math.round(y_offset * 10.0) / 10.0;
                        font-size: 13px;
                        color: black;
                    }
                    
                    // Zoom multiplier for reference
                    Text {
                        text: "(" + Math.round(zoom_scale * 100.0) / 100.0 + "x)";
                        font-size: 12px;
                        color: black;
                    }
                }
            }
            
            // Canvas with interactive area
            Rectangle {
                background: #2c3e50;
                vertical-stretch: 1;
                
                VerticalBox {
                    Rectangle {
                        vertical-stretch: 1;
                        background: #34495e;
                        
                        // Display rendered canvas image at native resolution (no scaling)
                        // ScrollView with TouchArea overlay for interaction
                        canvas_scroll := ScrollView {
                            viewport-width: 1600px;
                            viewport-height: 1200px;
                            
                            Rectangle {
                                width: 1600px;
                                height: 1200px;
                                
                                if root.canvas_image.width > 0 : Image {
                                    source: root.canvas_image;
                                    width: 1600px;
                                    height: 1200px;
                                }
                                
                                // Interactive layer on top of image
                                TouchArea {
                                    width: 100%;
                                    height: 100%;
                                    mouse-cursor: 
                                        designer_state.mode == 0 ? (
                                            root.hovered_handle == 0 || root.hovered_handle == 2 ? ns-resize :
                                            root.hovered_handle == 1 || root.hovered_handle == 3 ? ew-resize :
                                            root.dragging_shape_id >= 0 || (root.hovered_handle == 4 && designer_state.selected_id > 0) ? move :
                                            default
                                        ) :
                                        designer_state.mode == 1 ? crosshair :
                                        designer_state.mode == 2 ? crosshair :
                                        designer_state.mode == 3 ? crosshair :
                                        default;
                                    
                                    clicked => {
                                        // Don't handle click if a drag just occurred
                                        if !root.drag_occurred {
                                            // Adjust for scroll offset
                                            let adjusted_x = self.mouse-x / 1px + canvas_scroll.viewport-x / 1px;
                                            let adjusted_y = self.mouse-y / 1px + canvas_scroll.viewport-y / 1px;
                                            canvas_click(adjusted_x, adjusted_y);
                                        }
                                        root.drag_occurred = false;
                                    }
                                    
                                    // Detect handle on press down
                                    pointer-event(event) => {
                                        if event.kind == PointerEventKind.down && designer_state.mode == 0 {
                                            // Ask backend to detect which handle (if any) we're on
                                            let adjusted_x = self.pressed-x / 1px + canvas_scroll.viewport-x / 1px;
                                            let adjusted_y = self.pressed-y / 1px + canvas_scroll.viewport-y / 1px;
                                            root.dragging_handle = detect_handle(adjusted_x, adjusted_y);
                                            // Reset drag tracking for new press
                                            root.drag_start_initialized = false;
                                        }
                                    }
                                    
                                    // Track mouse movement - detect dragging and hover
                                    moved => {
                                        if designer_state.mode == 0 {
                                            // Check which handle we're hovering over
                                            let adjusted_x = self.mouse-x / 1px + canvas_scroll.viewport-x / 1px;
                                            let adjusted_y = self.mouse-y / 1px + canvas_scroll.viewport-y / 1px;
                                            root.hovered_handle = detect_handle(adjusted_x, adjusted_y);
                                        }
                                        
                                        if designer_state.mode == 0 && self.pressed {
                                            // Initialize drag start on first move while pressed
                                            if !root.drag_start_initialized {
                                                root.drag_start_x = self.pressed-x / 1px;
                                                root.drag_start_y = self.pressed-y / 1px;
                                                root.drag_start_initialized = true;
                                                root.drag_last_dx = 0.0;
                                                root.drag_last_dy = 0.0;
                                            }
                                            
                                            let total_dx = (self.mouse-x / 1px - root.drag_start_x);
                                            let total_dy = (self.mouse-y / 1px - root.drag_start_y);
                                            let inc_dx = total_dx - root.drag_last_dx;
                                            let inc_dy = total_dy - root.drag_last_dy;
                                            
                                            if abs(inc_dx) > 0.5 || abs(inc_dy) > 0.5 {
                                                if root.dragging_handle >= 0 && root.dragging_handle <= 3 {
                                                    // Dragging a resize handle (0-3)
                                                    // Use current selected_id, not cached dragging_shape_id
                                                    handle_drag(designer_state.selected_id, root.dragging_handle, inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                } else if root.dragging_handle == 4 || (root.dragging_handle == -1 && designer_state.selected_id > 0) {
                                                    // Dragging the shape itself (move) - handle is -1 or 4 (center)
                                                    handle_drag(designer_state.selected_id, root.dragging_handle, inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                } else if root.dragging_handle == -1 && designer_state.selected_id == 0 {
                                                    // No shape selected - pan the canvas
                                                    canvas_pan(inc_dx, inc_dy);
                                                    root.drag_occurred = true;
                                                }
                                                root.drag_last_dx = total_dx;
                                                root.drag_last_dy = total_dy;
                                            }
                                        } else if !self.pressed {
                                            // Reset when not pressed
                                            root.drag_last_dx = 0.0;
                                            root.drag_last_dy = 0.0;
                                            root.drag_start_initialized = false;
                                            root.dragging_handle = -1;
                                            root.dragging_shape_id = -1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    Text {
                        text: "Canvas - " + shapes.length + " shapes | Mode: " + 
                              (designer_state.mode == 0 ? "Select" :
                               designer_state.mode == 1 ? "Rectangle" :
                               designer_state.mode == 2 ? "Circle" : "Line");
                        font-size: 11px;
                    }
                }
            }
        }
        
        // ═════════════════════════════════════════════
        // RIGHT SIDEBAR: Properties Panel
        // ═════════════════════════════════════════════
        Rectangle {
            preferred-width: 200px;
            max-width: 200px;
            horizontal-stretch: 0;
            background: #ecf0f1;
            
        VerticalBox {
            spacing: 12px;
            padding: 12px;
            width: 100%;
            
            Text {
                text: "Tool Parameters";
                font-weight: 700;
                font-size: 14px;
            }
            
            VerticalBox {
                spacing: 4px;
                width: 100%;
                Text { 
                    text: "Feed:"; 
                    font-size: 11px; 
                }
                SpinBox { 
                    value: feed_rate; 
                    minimum: 0;
                    maximum: 10000;
                    preferred-width: 160px;
                }
            }
            
            VerticalBox {
                spacing: 4px;
                width: 100%;
                Text { 
                    text: "Spindle:"; 
                    font-size: 11px; 
                }
                SpinBox { 
                    value: spindle_speed;
                    minimum: 0;
                    maximum: 30000;
                    preferred-width: 160px;
                }
            }
            
            VerticalBox {
                spacing: 4px;
                width: 100%;
                Text { 
                    text: "Tool Ø:"; 
                    font-size: 11px; 
                }
                SpinBox { 
                    value: tool_diameter;
                    minimum: 0;
                    maximum: 50;
                    preferred-width: 160px;
                }
            }
            
            VerticalBox {
                spacing: 4px;
                width: 100%;
                Text { 
                    text: "Depth:"; 
                    font-size: 11px; 
                }
                SpinBox { 
                    value: cut_depth;
                    minimum: -100;
                    maximum: 0;
                    preferred-width: 160px;
                }
            }
            
            Rectangle { height: 8px; }
            
            Text {
                text: "Generate G-Code";
                font-weight: 700;
                font-size: 14px;
            }
            
            Button {
                text: "⚙ Generate";
                preferred-width: 160px;
                clicked => { generate_toolpath(); }
            }
            
            Button {
                text: "► Export";
                preferred-width: 160px;
                clicked => { export_gcode(); }
            }
            
            Text {
                text: gcode_generated ? "✓ Ready" : "⊘ No G-Code";
                font-size: 10px;
                color: gcode_generated ? #2ecc71 : #e74c3c;
                horizontal-alignment: center;
            }
            
            VerticalBox { }
        }
        }
    }
    }
}
