// Custom TextEdit widget with undo/redo support and virtual scrolling
// Optimized for large G-code files

import { ScrollView, VerticalBox, HorizontalBox } from "std-widgets.slint";

// Model for a single line of text
export struct TextLine {
    line_number: int,
    content: string,
    is_dirty: bool,
}

// Blinking cursor component
component BlinkingCursor inherits Rectangle {
    in property <length> x-pos: 0px;
    in property <length> y-pos: 0px;
    in property <length> cursor-width: 2px;
    in property <length> cursor-height: 20px;
    in property <bool> is-visible: true;
    
    width: cursor-width;
    height: cursor-height;
    background: #00ff00;
    opacity: is-visible ? 1.0 : 0.0;
}

// Custom text editor with virtual scrolling and undo/redo
export component CustomTextEdit inherits Rectangle {
    // Properties
    in-out property <string> text: "";
    in-out property <bool> read-only: false;
    in-out property <int> cursor-line: 1;
    in-out property <int> cursor-column: 1;
    in-out property <bool> show-line-numbers: true;
    in-out property <int> total-lines: 0;
    in-out property <int> visible-start-line: 0;
    in-out property <int> visible-end-line: 0;
    in-out property <[TextLine]> visible-lines: [];
    
    // Undo/Redo state
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    
    // Styling
    in-out property <brush> background-color: #1e1e1e;
    in-out property <brush> text-color: #00ff00;  // Bright green
    in-out property <brush> line-number-color: #cccccc;  // Light gray
    in-out property <brush> current-line-color: #2a2a2a;
    in-out property <brush> selection-color: #264f78;
    in-out property <brush> gutter-background-color: #252526;
    in-out property <length> font-size: 14px;
    in-out property <string> font-family: "Fira Code";
    
    // Character width for monospace font (Fira Code-Regular)
    // Calculated: font-size * (glyph-width / unitsPerEm) = 14px * (1200 / 1950)
    property <length> char-width: root.font-size * 1200 / 1950;
    
    // Callbacks
    callback text-changed(string);
    callback text-inserted(int, int, string);  // line, column, text
    callback text-deleted(int, int, int, int);  // start-line, start-col, end-line, end-col
    callback cursor-moved(int, int);
    callback undo-requested();
    callback redo-requested();
     callback scroll-changed(int);
    callback ensure-cursor-visible();  // Request scroll to keep cursor in view
    callback end-key-pressed();  // End key pressed - let Rust handle positioning to line end
    callback ctrl-home-pressed();  // Ctrl+Home pressed - jump to beginning of file
    callback ctrl-end-pressed();  // Ctrl+End pressed - jump to end of file
    callback key-pressed(KeyEvent) -> EventResult;
    callback request-focus();  // Request focus on the text edit
    callback text-area-clicked();  // Debug: Track clicks on text area
    
    // Cursor blink state controlled by Rust timer
    in-out property <bool> cursor-blink-visible: true;
    
    // Internal state
    property <length> line-height: 20px;
    property <length> line-number-width: 60px;
    property <length> sync-scroll-y: 0px;
    property <bool> focus-requested: false;
    property <int> cursor-blink-trigger: 0;
    
    // When this property is set to true, request focus
    in-out property <int> focus-trigger: 0;
    
    // Watch focus-trigger property changes
    changed focus-trigger => {
        fs.focus();
    }
    
    background: root.background-color;
    
    HorizontalBox {
        spacing: 0px;
        // Line numbers column (optional)
        if root.show-line-numbers: Rectangle {
            width: root.line-number-width;
            background: root.gutter-background-color;
            
            Flickable {
                viewport-y: root.sync-scroll-y;
                interactive: false;
                // Match the main text area viewport height
                viewport-height: root.total-lines * root.line-height + 20px;
                
                VerticalLayout {
                    alignment: start;
                    spacing: 0px;
                    padding-top: 12px;
                    padding-bottom: 20px;
                    padding-left: 5px;
                    padding-right: 0px;
                    
                    if root.visible-start-line > 0: Rectangle {
                        height: root.visible-start-line * root.line-height;
                    }
                    
                    for line in root.visible-lines: Rectangle {
                        height: root.line-height;

                        HorizontalLayout {
                            padding: 0px;
                            alignment: center;

                            VerticalLayout {
                                alignment: center;
                                padding: 0px;

                                Text {
                                    text: root.visible-start-line + (line.line-number - root.visible-lines[0].line-number) + 1;
                                    color: root.line-number-color;
                                    font-size: root.font-size;
                                    font-family: root.font-family;
                                    horizontal-alignment: right;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Main text area with virtual scrolling
        text-flickable := Flickable {
            horizontal-stretch: 1.0;
            vertical-stretch: 1.0;
            interactive: true;
            // Add extra padding to viewport height to ensure last line is fully visible
            viewport-height: root.total-lines * root.line-height + 20px;
            
            touch-in-editor := TouchArea {
                clicked => {
                    root.text-area-clicked();
                    fs.focus();
                    
                    // Calculate line and column from click position
                    let mouse_y_px = self.mouse-y + 10px;  // Add half a line-height for better centering
                    let mouse_x_px = self.mouse-x;
                    
                    // Calculate which line was clicked (accounting for visible-start-line)
                    let line_offset = (mouse_y_px - 12px) / root.line-height;
                    let clicked_line = root.visible-start-line + line_offset;
                    
                    // Calculate column from horizontal position
                    let col_offset = mouse_x_px / root.char-width;
                    
                    root.cursor_moved(clicked_line, col_offset);
                }
            }
            
            VerticalLayout {
                spacing: 0px;
                alignment: start;
                padding-top: 12px;
                padding-bottom: 20px;
                padding-left: 5px;
                padding-right: 5px;
                
                // Spacer: positions visible lines at correct offset
                // Uses first line's actual line number from backend (line numbers start at 1)
                if root.visible-lines.length > 0: Rectangle {
                    height: (root.visible-lines[0].line-number - 1) * root.line-height;
                }
                
                // Render only visible lines
                for line in root.visible-lines: Rectangle {
                    height: root.line-height;
                    
                    // Highlight current line
                    background: line.line-number == root.cursor-line ? root.current-line-color : transparent;
                    
                    HorizontalLayout {
                        padding: 0px;
                        alignment: start;

                        VerticalLayout {
                            alignment: center;
                            padding: 0px;

                            Text {
                                text: line.content;
                                color: root.text-color;
                                font-size: root.font-size;
                                font-family: root.font-family;
                                horizontal-alignment: left;
                                overflow: elide;
                            }
                        }
                    }
                    
                    // Render cursor if this is the cursor line
                    if (line.line-number == root.cursor-line) : BlinkingCursor {
                        x: (root.cursor-column - 1) * root.char-width;
                        y: 0px;
                        cursor-width: 2px;
                        cursor-height: root.line-height;
                        is-visible: root.cursor-blink-visible;
                    }
                }
            }
            
            changed viewport-y => {
                // Update sync property to synchronize line numbers
                root.sync-scroll-y = text-flickable.viewport-y;
                
                // Calculate which lines should be visible at current scroll position
                // viewport-y is negative when scrolled down, so negate it to get scroll offset
                root.visible-start-line = Math.max(0, Math.floor(-text-flickable.viewport-y / root.line-height));
                // Use floor instead of ceil to show only fully visible lines (no partial lines)
                root.visible-end-line = root.visible-start-line + Math.floor(text-flickable.height / root.line-height);
                
                // Request lines from backend (will clamp to valid range)
                root.scroll-changed(root.visible-start-line);
            }
        }
        
        // Mouse interaction overlay for cursor positioning - DISABLED for now
        // Arrow keys work perfectly, so mouse clicking is lower priority
        // TODO: Fix TouchArea event handling within Flickable context
    }
    
    // Keyboard and mouse interaction  
    
    fs := FocusScope {
        key-pressed(event) => {
            // Handle arrow keys for cursor navigation
            if (event.text == Key.LeftArrow) {
                let new_col = root.cursor-column - 1;
                root.cursor-moved(root.cursor-line, new_col);
                return accept;
            }
            if (event.text == Key.RightArrow) {
                let new_col = root.cursor-column + 1;
                root.cursor-moved(root.cursor-line, new_col);
                return accept;
            }
            if (event.text == Key.UpArrow) {
                let new_line = Math.max(1, root.cursor-line - 1);
                // Don't set root.cursor-line here - let Rust handler do it after clamping
                root.cursor-moved(new_line, root.cursor-column);
                return accept;
            }
            if (event.text == Key.DownArrow) {
                let new_line = Math.min(root.total-lines, root.cursor-line + 1);
                // Don't set root.cursor-line here - let Rust handler do it after clamping
                root.cursor-moved(new_line, root.cursor-column);
                return accept;
            }
            
            // Handle Home key
            if (event.text == Key.Home) {
                // Don't set root.cursor-column - let Rust handler do it
                root.cursor-moved(root.cursor-line, 1);
                return accept;
            }
            
            // Handle End key - move to end of current line
            // Note: We don't know actual line length from Slint, so use large number
            // The backend will clamp to actual line end
            if (event.text == Key.End) {
                root.end-key-pressed();
                return accept;
            }
            
            // Handle Tab key
            if (event.text == Key.Tab) {
                root.text-inserted(root.cursor-line, root.cursor-column, "    ");
                return accept;
            }
            
            // Handle PageUp/PageDown
            if (event.text == Key.PageUp) {
                let new_line = Math.max(1, root.cursor-line - 10);
                // Don't set root.cursor-line - let Rust handler do it
                root.cursor-moved(new_line, root.cursor-column);
                return accept;
            }
            if (event.text == Key.PageDown) {
                let new_line = Math.min(root.total-lines, root.cursor-line + 10);
                // Don't set root.cursor-line - let Rust handler do it
                root.cursor-moved(new_line, root.cursor-column);
                return accept;
            }
            
            // Handle undo/redo shortcuts
            if (event.modifiers.control || event.modifiers.meta) {
                if (event.text == "z" || event.text == "Z") {
                    if (event.modifiers.shift) {
                        root.redo-requested();
                    } else {
                        root.undo-requested();
                    }
                    return accept;
                }
                
                if (event.text == "y" || event.text == "Y") {
                    root.redo-requested();
                    return accept;
                }
                
                // Ctrl+Home: Jump to beginning of file
                if (event.text == Key.Home) {
                    root.ctrl-home-pressed();
                    return accept;
                }
                
                // Ctrl+End: Jump to end of file
                if (event.text == Key.End) {
                    root.ctrl-end-pressed();
                    return accept;
                }
            }
            
            // Handle backspace
            if (event.text == Key.Backspace) {
                root.text-deleted(root.cursor-line, root.cursor-column - 1, root.cursor-line, root.cursor-column);
                return accept;
            }
            
            // Handle delete
            if (event.text == Key.Delete) {
                root.text-deleted(root.cursor-line, root.cursor-column, root.cursor-line, root.cursor-column + 1);
                return accept;
            }
            
            // Handle enter key - insert newline
            if (event.text == Key.Return) {
                root.text-inserted(root.cursor-line, root.cursor-column, "\n");
                return accept;
            }
            
            // Handle regular character input - any printable character
            if (event.text != "" && event.text != Key.Escape &&
                !(event.modifiers.control || event.modifiers.meta)) {
                root.text-inserted(root.cursor-line, root.cursor-column, event.text);
                return accept;
            }
            
            // Pass other keys to callback for handling
            return root.key-pressed(event);
        }
    }
    
    // Auto-scroll to keep cursor visible when cursor line changes
    changed cursor-line => {
        // Restart cursor blink animation
        root.cursor-blink-trigger = root.cursor-blink-trigger + 1;
        
        // Scroll viewport if cursor is outside visible area
        // cursor-line is 1-based (1 = first line, 2 = second line, etc.)
        // visible-start-line is 0-based (0 = first line visible, 1 = second line visible, etc.)
        // Use floor to calculate only fully visible lines
        let visible_height_lines = Math.floor(text-flickable.height / root.line-height);
        // First visible line in 1-based numbering
        let first_visible_line_1based = root.visible-start-line + 1;
        // Last fully visible line in 1-based numbering
        let last_visible_line_1based = root.visible-start-line + visible_height_lines;
        
        if root.cursor-line < first_visible_line_1based {
            // Cursor moved above visible area, scroll up to show cursor at top
            text-flickable.viewport-y = -(root.cursor-line - 1) * root.line-height;
        } else if root.cursor-line > last_visible_line_1based {
            // Cursor moved below visible area, scroll down to show cursor at bottom
            let new_start = Math.max(0, root.cursor-line - visible_height_lines);
            text-flickable.viewport-y = -new_start * root.line-height;
        }
    }
}

// Toolbar with undo/redo buttons
export component EditorToolbar inherits Rectangle {
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    
    callback undo-clicked();
    callback redo-clicked();
    callback save-clicked();
    callback open-clicked();
    
    height: 40px;
    background: #2d2d30;
    
    HorizontalBox {
        padding: 5px;
        spacing: 5px;
        
        // Undo button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            undo-area := TouchArea {
                enabled: root.can-undo;
                clicked => {
                    root.undo-clicked();
                }
            }
            
            background: undo-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "‚éå Undo";
                    color: root.can-undo ? #ffffff : #666666;
                    font-size: 12px;
                }
            }
        }
        
        // Redo button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            redo-area := TouchArea {
                enabled: root.can-redo;
                clicked => {
                    root.redo-clicked();
                }
            }
            
            background: redo-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "‚éå Redo";
                    color: root.can-redo ? #ffffff : #666666;
                    font-size: 12px;
                }
            }
        }
        
        Rectangle {
            width: 10px;
        }
        
        // Save button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            save-area := TouchArea {
                clicked => {
                    root.save-clicked();
                }
            }
            
            background: save-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "üíæ Save";
                    color: #ffffff;
                    font-size: 12px;
                }
            }
        }
        
        // Open button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            open-area := TouchArea {
                clicked => {
                    root.open-clicked();
                }
            }
            
            background: open-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "üìÅ Open";
                    color: #ffffff;
                    font-size: 12px;
                }
            }
        }
        
        // Status text on the right
        Rectangle {
            horizontal-stretch: 1;
        }
        
        Text {
            text: "Ready";
            color: #cccccc;
            font-size: 12px;
            vertical-alignment: center;
        }
    }
}

// Complete editor component with toolbar
export component CodeEditor inherits VerticalBox {
    in-out property <string> content: "";
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    in-out property <int> cursor-line: 0;
    in-out property <int> cursor-column: 0;
    in-out property <[TextLine]> visible-lines: [];
    in-out property <int> total-lines: 0;
    
    callback text-changed(string);
    callback undo-requested();
    callback redo-requested();
    callback save-requested();
    callback open-requested();
    callback scroll-changed(int);
    
    spacing: 0px;
    
    // Toolbar
    EditorToolbar {
        can-undo: root.can-undo;
        can-redo: root.can-redo;
        
        undo-clicked => {
            root.undo-requested();
        }
        
        redo-clicked => {
            root.redo-requested();
        }
        
        save-clicked => {
            root.save-requested();
        }
        
        open-clicked => {
            root.open-requested();
        }
    }
    
    // Editor
    CustomTextEdit {
        text: root.content;
        can-undo: root.can-undo;
        can-redo: root.can-redo;
        cursor-line: root.cursor-line;
        cursor-column: root.cursor-column;
        visible-lines: root.visible-lines;
        total-lines: root.total-lines;
        
        text-changed(text) => {
            root.text-changed(text);
        }
        
        undo-requested => {
            root.undo-requested();
        }
        
        redo-requested => {
            root.redo-requested();
        }
        
        scroll-changed(line) => {
            root.scroll-changed(line);
        }
    }
}
