// Custom TextEdit widget with undo/redo support and virtual scrolling
// Optimized for large G-code files

import { ScrollView, VerticalBox, HorizontalBox } from "std-widgets.slint";

// Model for a single line of text
export struct TextLine {
    line_number: int,
    content: string,
    is_dirty: bool,
}

// Custom text editor with virtual scrolling and undo/redo
export component CustomTextEdit inherits Rectangle {
    // Properties
    in-out property <string> text: "";
    in-out property <bool> read-only: false;
    in-out property <int> cursor-line: 0;
    in-out property <int> cursor-column: 0;
    in-out property <bool> show-line-numbers: true;
    in-out property <int> total-lines: 0;
    in-out property <int> visible-start-line: 0;
    in-out property <int> visible-end-line: 0;
    in-out property <[TextLine]> visible-lines: [];
    
    // Undo/Redo state
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    
    // Styling
    in-out property <brush> background-color: #1e1e1e;
    in-out property <brush> text-color: #00ff00;  // Bright green
    in-out property <brush> line-number-color: #cccccc;  // Light gray
    in-out property <brush> current-line-color: #2a2a2a;
    in-out property <brush> selection-color: #264f78;
    in-out property <length> font-size: 14px;
    in-out property <string> font-family: "monospace";
    
    // Callbacks
    callback text-changed(string);
    callback text-inserted(int, int, string);  // line, column, text
    callback text-deleted(int, int, int, int);  // start-line, start-col, end-line, end-col
    callback cursor-moved(int, int);
    callback undo-requested();
    callback redo-requested();
    callback scroll-changed(int);
    callback key-pressed(KeyEvent) -> EventResult;
    
    // Internal state
    property <length> line-height: 20px;
    property <length> line-number-width: 60px;
    property <length> sync-scroll-y: 0px;
    
    background: root.background-color;
    
    HorizontalBox {
        spacing: 0px;
        // Line numbers column (optional)
        if root.show-line-numbers: Rectangle {
            width: root.line-number-width;
            background: #252526;
            
            Flickable {
                viewport-y: root.sync-scroll-y;
                interactive: false;
                // Match the main text area viewport height
                viewport-height: root.total-lines * root.line-height + 20px;
                
                VerticalLayout {
                    alignment: start;
                    spacing: 0px;
                    padding-top: 12px;
                    padding-bottom: 20px;
                    padding-left: 5px;
                    padding-right: 0px;
                    
                    if root.visible-start-line > 0: Rectangle {
                        height: root.visible-start-line * root.line-height;
                    }
                    
                    for line in root.visible-lines: Rectangle {
                        height: root.line-height;

                        HorizontalLayout {
                            padding: 0px;
                            alignment: center;

                            VerticalLayout {
                                alignment: center;
                                padding: 0px;

                                Text {
                                    text: root.visible-start-line + (line.line-number - root.visible-lines[0].line-number) + 1;
                                    color: root.line-number-color;
                                    font-size: root.font-size;
                                    font-family: root.font-family;
                                    horizontal-alignment: right;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Main text area with virtual scrolling
        text-flickable := Flickable {
            horizontal-stretch: 1.0;
            vertical-stretch: 1.0;
            interactive: true;
            // Add extra padding to viewport height to ensure last line is fully visible
            viewport-height: root.total-lines * root.line-height + 20px;
            
            // Mouse interaction for cursor positioning
            TouchArea {
                clicked => {
                    // Give focus to FocusScope so keyboard works
                    focus-scope.focus();
                    
                    // Calculate line and column from mouse position
                    // self.mouse-x and self.mouse-y are available in clicked handler
                    let line = Math.floor(self.mouse-y / root.line-height) + root.visible-start-line + 1;
                    let col = Math.floor(self.mouse-x / 8px) + 1;
                    root.cursor-moved(line, Math.max(1, col));
                }
            }
            
            VerticalLayout {
                spacing: 0px;
                alignment: start;
                padding-top: 12px;
                padding-bottom: 20px;
                padding-left: 5px;
                padding-right: 5px;
                
                // Spacer: positions visible lines at correct offset
                // Uses first line's actual line number from backend (line numbers start at 1)
                if root.visible-lines.length > 0: Rectangle {
                    height: (root.visible-lines[0].line-number - 1) * root.line-height;
                }
                
                // Render only visible lines
                for line in root.visible-lines: Rectangle {
                    height: root.line-height;
                    
                    // Highlight current line
                    background: line.line-number == root.cursor-line ? root.current-line-color : transparent;
                    
                    HorizontalLayout {
                        padding: 0px;
                        alignment: start;

                        VerticalLayout {
                            alignment: center;
                            padding: 0px;

                            Text {
                                text: line.content;
                                color: root.text-color;
                                font-size: root.font-size;
                                font-family: root.font-family;
                                horizontal-alignment: left;
                                overflow: elide;
                            }
                        }
                    }
                    
                    // Render cursor if this is the cursor line
                    if (line.line-number == root.cursor-line) : Rectangle {
                        x: (root.cursor-column - 1) * 8px;  // Convert from 1-based to 0-based for rendering
                        y: 0px;
                        width: 2px;
                        height: root.line-height;
                        background: #00ff00;
                    }
                }
            }

            
            changed viewport-y => {
                // Update sync property to synchronize line numbers
                root.sync-scroll-y = self.viewport-y;
                
                // Calculate which lines should be visible at current scroll position
                // viewport-y is negative when scrolled down, so negate it to get scroll offset
                root.visible-start-line = Math.max(0, Math.floor(-self.viewport-y / root.line-height));
                root.visible-end-line = root.visible-start-line + Math.ceil(self.height / root.line-height);
                
                // Request lines from backend (will clamp to valid range)
                root.scroll-changed(root.visible-start-line);
            }
        }
    }
    
    // Keyboard and mouse interaction  
    // Invisible TextInput overlay to capture keyboard input
    text-input := TextInput {
        x: 0px;
        y: 0px;
        width: 0px;
        height: 0px;
        opacity: 0;
        single-line: false;
        
        accepted => {
            // Enter key pressed - insert newline
            root.text-inserted(root.cursor-line, root.cursor-column, "\n");
        }
        
        edited => {
            // Text changed - insert the new text
            if (self.text != "") {
                root.text-inserted(root.cursor-line, root.cursor-column, self.text);
                self.text = "";
            }
        }
    }
    
    FocusScope {
        focus-scope := FocusScope {}
        
        key-pressed(event) => {
            debug("üîµ CustomTextEdit.key-pressed: text=[" + event.text + "]");
            debug("KEY-PRESSED: text=[" + event.text + "]");
            // Handle arrow keys for cursor navigation
            if (event.text == Key.LeftArrow) {
                debug("LEFT ARROW: moving cursor left");
                root.cursor-moved(root.cursor-line, Math.max(1, root.cursor-column - 1));
                return accept;
            }
            if (event.text == Key.RightArrow) {
                debug("RIGHT ARROW: moving cursor right");
                root.cursor-moved(root.cursor-line, root.cursor-column + 1);
                return accept;
            }
            if (event.text == Key.UpArrow) {
                debug("UP ARROW: moving cursor up");
                root.cursor-moved(Math.max(1, root.cursor-line - 1), root.cursor-column);
                return accept;
            }
            if (event.text == Key.DownArrow) {
                debug("DOWN ARROW: moving cursor down");
                root.cursor-moved(Math.min(root.total-lines, root.cursor-line + 1), root.cursor-column);
                return accept;
            }
            
            // Handle Home key
            if (event.text == Key.Home) {
                root.cursor-moved(root.cursor-line, 1);
                return accept;
            }
            
            // Handle End key
            if (event.text == Key.End) {
                root.cursor-moved(root.cursor-line, 10000);
                return accept;
            }
            
            // Handle Tab key
            if (event.text == Key.Tab) {
                root.text-inserted(root.cursor-line, root.cursor-column, "    ");
                return accept;
            }
            
            // Handle PageUp/PageDown
            if (event.text == Key.PageUp) {
                root.cursor-moved(Math.max(1, root.cursor-line - 10), root.cursor-column);
                return accept;
            }
            if (event.text == Key.PageDown) {
                root.cursor-moved(Math.min(root.total-lines, root.cursor-line + 10), root.cursor-column);
                return accept;
            }
            
            // Handle undo/redo shortcuts
            if (event.modifiers.control || event.modifiers.meta) {
                if (event.text == "z" || event.text == "Z") {
                    if (event.modifiers.shift) {
                        root.redo-requested();
                    } else {
                        root.undo-requested();
                    }
                    return accept;
                }
                
                if (event.text == "y" || event.text == "Y") {
                    root.redo-requested();
                    return accept;
                }
            }
            
            // Handle backspace
            if (event.text == Key.Backspace) {
                root.text-deleted(root.cursor-line, root.cursor-column - 1, root.cursor-line, root.cursor-column);
                return accept;
            }
            
            // Handle delete
            if (event.text == Key.Delete) {
                root.text-deleted(root.cursor-line, root.cursor-column, root.cursor-line, root.cursor-column + 1);
                return accept;
            }
            
            // Handle enter key - insert newline
            if (event.text == Key.Return) {
                root.text-inserted(root.cursor-line, root.cursor-column, "\n");
                return accept;
            }
            
            // Handle regular character input - any printable character
            if (event.text != "" && event.text != Key.Escape &&
                !(event.modifiers.control || event.modifiers.meta)) {
                debug("üîµ CustomTextEdit.key-pressed: Inserting character: " + event.text + " at line=" + root.cursor-line + " col=" + root.cursor-column);
                debug("üîµ CustomTextEdit calling root.text-inserted()");
                root.text-inserted(root.cursor-line, root.cursor-column, event.text);
                return accept;
            }
            
            // Pass other keys to callback for handling
            return root.key-pressed(event);
        }
    }
}

// Toolbar with undo/redo buttons
export component EditorToolbar inherits Rectangle {
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    
    callback undo-clicked();
    callback redo-clicked();
    callback save-clicked();
    callback open-clicked();
    
    height: 40px;
    background: #2d2d30;
    
    HorizontalBox {
        padding: 5px;
        spacing: 5px;
        
        // Undo button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            undo-area := TouchArea {
                enabled: root.can-undo;
                clicked => {
                    root.undo-clicked();
                }
            }
            
            background: undo-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "‚éå Undo";
                    color: root.can-undo ? #ffffff : #666666;
                    font-size: 12px;
                }
            }
        }
        
        // Redo button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            redo-area := TouchArea {
                enabled: root.can-redo;
                clicked => {
                    root.redo-clicked();
                }
            }
            
            background: redo-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "‚éå Redo";
                    color: root.can-redo ? #ffffff : #666666;
                    font-size: 12px;
                }
            }
        }
        
        Rectangle {
            width: 10px;
        }
        
        // Save button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            save-area := TouchArea {
                clicked => {
                    root.save-clicked();
                }
            }
            
            background: save-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "üíæ Save";
                    color: #ffffff;
                    font-size: 12px;
                }
            }
        }
        
        // Open button
        Rectangle {
            width: 80px;
            height: 30px;
            border-radius: 3px;
            border-width: 1px;
            border-color: #555555;
            
            open-area := TouchArea {
                clicked => {
                    root.open-clicked();
                }
            }
            
            background: open-area.has-hover ? #3e3e42 : #333337;
            
            HorizontalBox {
                alignment: center;
                Text {
                    text: "üìÅ Open";
                    color: #ffffff;
                    font-size: 12px;
                }
            }
        }
        
        // Status text on the right
        Rectangle {
            horizontal-stretch: 1;
        }
        
        Text {
            text: "Ready";
            color: #cccccc;
            font-size: 12px;
            vertical-alignment: center;
        }
    }
}

// Complete editor component with toolbar
export component CodeEditor inherits VerticalBox {
    in-out property <string> content: "";
    in-out property <bool> can-undo: false;
    in-out property <bool> can-redo: false;
    in-out property <int> cursor-line: 0;
    in-out property <int> cursor-column: 0;
    in-out property <[TextLine]> visible-lines: [];
    in-out property <int> total-lines: 0;
    
    callback text-changed(string);
    callback undo-requested();
    callback redo-requested();
    callback save-requested();
    callback open-requested();
    callback scroll-changed(int);
    
    spacing: 0px;
    
    // Toolbar
    EditorToolbar {
        can-undo: root.can-undo;
        can-redo: root.can-redo;
        
        undo-clicked => {
            root.undo-requested();
        }
        
        redo-clicked => {
            root.redo-requested();
        }
        
        save-clicked => {
            root.save-requested();
        }
        
        open-clicked => {
            root.open-requested();
        }
    }
    
    // Editor
    CustomTextEdit {
        text: root.content;
        can-undo: root.can-undo;
        can-redo: root.can-redo;
        cursor-line: root.cursor-line;
        cursor-column: root.cursor-column;
        visible-lines: root.visible-lines;
        total-lines: root.total-lines;
        
        text-changed(text) => {
            root.text-changed(text);
        }
        
        undo-requested => {
            root.undo-requested();
        }
        
        redo-requested => {
            root.redo-requested();
        }
        
        scroll-changed(line) => {
            root.scroll-changed(line);
        }
    }
}
